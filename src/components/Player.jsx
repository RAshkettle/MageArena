/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/Skeleton.glb -o src/components/Player.jsx -r public 
*/

import React, { useEffect } from "react";
import { useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import { useControls, folder, button } from "leva";
import { RigidBody, CapsuleCollider } from "@react-three/rapier";
import * as THREE from "three";
import PLAYER_ANIMS from "./player_animations";

/**
 * @typedef {Object} PlayerProps
 * @property {number} [position.x=0] - X position of the player
 * @property {number} [position.y=0] - Y position of the player
 * @property {number} [position.z=0] - Z position of the player
 * @property {number} [scale=1] - Scale of the player model
 * @property {boolean} [visible=true] - Whether the player is visible
 */

/**
 * Player component that renders a 3D skeleton model with animations
 *
 * @param {PlayerProps} props - The component props
 * @returns {JSX.Element} The player mesh component
 */
export function Player(props) {
  /** @type {React.RefObject<import('three').Group>} */
  const group = React.useRef();
  /** @type {React.RefObject<import('@react-three/rapier').RigidBody>} */
  const rigidBodyRef = React.useRef();

  // Define fixed collider dimensions
  const colliderHeight = 0.5;
  const colliderRadius = 0.5;
  const colliderOffsetY = 0.7;

  /** @type {Object} scene - The loaded 3D model scene */
  /** @type {Array<import('three').AnimationClip>} animations - The loaded animations */
  const { scene, animations } = useGLTF("/Skeleton.glb");

  /** @type {import('three').Object3D} Clone of the scene for instancing */
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);

  /** @type {Object} nodes - The 3D model nodes */
  /** @type {Object} materials - The 3D model materials */
  const { nodes, materials } = useGraph(clone);

  /** @type {Object.<string, import('three').AnimationAction>} actions - Available animation actions */
  const { actions, names } = useAnimations(animations, group);

  // Access the Physics control panel for shared properties
  const { showColliders } = useControls("Physics", {
    showColliders: false,
  });

  // Player-specific controls
  const {
    animation,
    loopAnimation,
    animationSpeed,
  } = useControls("Player", {
    Animation: folder({
      animation: {
        options: names,
        value: PLAYER_ANIMS.IDLE,
      },
      loopAnimation: true,
      animationSpeed: { value: 1, min: 0.1, max: 2, step: 0.1 },
      copyToClipboard: button(() => {
        if (animation) {
          navigator.clipboard
            .writeText(animation)
            .then(() =>
              console.log(`Animation name "${animation}" copied to clipboard!`)
            )
            .catch((err) =>
              console.error("Could not copy animation name: ", err)
            );
        }
      }),
    }),
  });

  // Play the selected animation with the chosen settings
  useEffect(() => {
    // Reset all animations
    Object.values(actions).forEach((action) => {
      action.stop();
    });

    if (animation && actions[animation]) {
      const currentAction = actions[animation];

      // Set loop mode based on toggle
      currentAction.loop = loopAnimation ? THREE.LoopRepeat : THREE.LoopOnce;

      // If not looping, make sure to clamp when finished
      if (!loopAnimation) {
        currentAction.clampWhenFinished = true;
      }

      // Set playback speed
      currentAction.timeScale = animationSpeed;

      // Play the animation
      currentAction.reset().play();
    }
  }, [animation, loopAnimation, animationSpeed, actions]);

  return (
    <RigidBody
      ref={rigidBodyRef}
      position={[0, colliderHeight / 2, 0]}
      enabledRotations={[false, false, false]}
      lockRotations={true}
      mass={1}
      type="dynamic"
      colliders={false}
      linearDamping={1}
      angularDamping={1}
      friction={0.5}
    >
      {/* Capsule collider for the player */}
      <CapsuleCollider
        args={[colliderHeight / 2, colliderRadius]}
        position={[0, colliderOffsetY, 0]}
      />

      {/* Debug visualization for the collider */}
      {showColliders && (
        <mesh position={[0, colliderOffsetY, 0]}>
          <capsuleGeometry args={[colliderRadius, colliderHeight]} />
          <meshBasicMaterial color="red" transparent opacity={0.3} wireframe />
        </mesh>
      )}

      {/* The actual player model */}
      <group ref={group} {...props} dispose={null} position={[0, 0, 0]}>
        <group name="Root_Scene">
          <group name="RootNode">
            <group
              name="CharacterArmature"
              rotation={[-Math.PI / 2, 0, 0]}
              scale={100}
            >
              <primitive object={nodes.Root} />
            </group>
            <skinnedMesh
              name="Skeleton"
              geometry={nodes.Skeleton.geometry}
              material={materials.AtlasMaterial}
              skeleton={nodes.Skeleton.skeleton}
              rotation={[-Math.PI / 2, 0, 0]}
              scale={100}
            />
          </group>
        </group>
      </group>
    </RigidBody>
  );
}

// Preload the 3D model for performance
useGLTF.preload("/Skeleton.glb");

export default Player;
