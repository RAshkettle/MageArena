/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/Skeleton.glb -o src/components/Player.jsx -r public 
*/

import React, { useEffect, useState, useRef } from "react";
import { useGraph, useFrame } from "@react-three/fiber";
import { useGLTF, useAnimations, useKeyboardControls } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import { useControls, folder, button } from "leva";
import * as THREE from "three";
import PLAYER_ANIMS, { getSimpleName } from "./player_animations";

// Player state machine states
const PlayerState = {
  IDLE: "idle",
  WALK: "walk",
  RUN: "run",
  JUMP: "jump",
  ATTACK: "attack",
  SPELL_CAST: "spellcast",
  HIT_REACT: "hitreact",
  DEATH: "death",
};

/**
 * @typedef {Object} PlayerProps
 * @property {number} [position] - Array or Vector3 for player position [x, y, z]
 * @property {number} [positionX=0] - X position of the player
 * @property {number} [positionY=0] - Y position of the player
 * @property {number} [positionZ=0] - Z position of the player
 * @property {number} [scale=1] - Scale of the player model
 * @property {boolean} [visible=true] - Whether the player is visible
 */

/**
 * Player component that renders a 3D skeleton model with animations
 *
 * @param {PlayerProps} props - The component props
 * @returns {JSX.Element} The player mesh component
 */
export function Player({
  position = [0, 0, 0],
  positionX,
  positionY,
  positionZ,
  scale = 1,
  ...props
}) {
  // State machine for player animations
  const [playerState, setPlayerState] = useState(PlayerState.IDLE);
  const prevPositionRef = useRef([0, 0, 0]);
  const lastAnimationTimeRef = useRef(0);
  const isInCombatRef = useRef(false);
  const isOnGround = useRef(true); // Track if the player is on the ground

  // Movement detection threshold
  const MOVEMENT_THRESHOLD = 0.005;
  const ANIMATION_COOLDOWN = 0.5; // seconds

  // Get movement controls state
  const [, get] = useKeyboardControls();

  // Allow individual position coordinates to override the position array
  const finalPosition = [
    positionX !== undefined ? positionX : position[0],
    positionY !== undefined ? positionY : position[1],
    positionZ !== undefined ? positionZ : position[2],
  ];

  /** @type {React.RefObject<import('three').Group>} */
  const group = useRef();

  // Load the model
  const { scene, animations } = useGLTF("./Skeleton.glb");

  // Create a clone of the scene with proper skeleton handling
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);

  // Extract nodes and materials from the cloned scene
  const { nodes, materials } = useGraph(clone);

  // Set up animations
  const { actions, mixer } = useAnimations(animations, group);

  // Get the animation name for a given state
  const getAnimationForState = (state) => {
    switch (state) {
      case PlayerState.IDLE:
        return PLAYER_ANIMS.IDLE;
      case PlayerState.WALK:
        return PLAYER_ANIMS.WALK;
      case PlayerState.RUN:
        return PLAYER_ANIMS.RUN;
      case PlayerState.JUMP:
        return PLAYER_ANIMS.JUMP;
      case PlayerState.ATTACK:
        return PLAYER_ANIMS.ATTACK;
      case PlayerState.SPELL_CAST:
        return PLAYER_ANIMS.SPELL_CAST;
      case PlayerState.HIT_REACT:
        return PLAYER_ANIMS.HIT_REACT;
      case PlayerState.DEATH:
        return PLAYER_ANIMS.DEATH;
      default:
        return PLAYER_ANIMS.IDLE;
    }
  };

  // Crossfade to a new animation
  const fadeToAction = (newAction, duration = 0.2) => {
    if (!actions[newAction]) {
      console.warn(`Animation "${newAction}" not found!`);
      return;
    }

    const currentActions = Object.values(actions).filter(
      (action) => action.isRunning() && action._clip.name !== newAction
    );

    if (currentActions.length > 0) {
      // Set up crossfade from all currently running animations
      actions[newAction].reset();
      actions[newAction].clampWhenFinished = false;
      actions[newAction].setLoop(THREE.LoopRepeat);
      actions[newAction].play();

      currentActions.forEach((action) => {
        actions[newAction].crossFadeFrom(action, duration, true);
      });
    } else {
      // Just play the new animation
      actions[newAction].reset();
      actions[newAction].setLoop(THREE.LoopRepeat);
      actions[newAction].play();
    }

    // Handle non-looping animations
    if (
      newAction === PLAYER_ANIMS.ATTACK ||
      newAction === PLAYER_ANIMS.SPELL_CAST ||
      newAction === PLAYER_ANIMS.HIT_REACT
    ) {
      actions[newAction].setLoop(THREE.LoopOnce);
      actions[newAction].clampWhenFinished = true;

      // Set callback to return to idle when finished
      mixer.addEventListener("finished", (e) => {
        if (e.action._clip.name === newAction) {
          setPlayerState(PlayerState.IDLE);
          isInCombatRef.current = false;
        }
      });
    }
  };

  // Effect to play the appropriate animation when state changes
  useEffect(() => {
    if (actions) {
      const animationName = getAnimationForState(playerState);
      fadeToAction(animationName);
      console.log(`Animation changed to: ${playerState} (${animationName})`);
    }
  }, [playerState, actions]);

  // Start with idle animation when component mounts
  useEffect(() => {
    if (actions && actions[PLAYER_ANIMS.IDLE]) {
      fadeToAction(PLAYER_ANIMS.IDLE);
      console.log("Initial idle animation started");
    }
  }, [actions]);

  // Register additional key bindings for combat actions
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Don't trigger new animations if we're in the middle of a combat animation
      if (isInCombatRef.current) return;

      const now = performance.now() / 1000;
      if (now - lastAnimationTimeRef.current < ANIMATION_COOLDOWN) return;

      if (e.code === "KeyF") {
        setPlayerState(PlayerState.ATTACK);
        isInCombatRef.current = true;
        lastAnimationTimeRef.current = now;
      } else if (e.code === "KeyR") {
        setPlayerState(PlayerState.SPELL_CAST);
        isInCombatRef.current = true;
        lastAnimationTimeRef.current = now;
      } else if (e.code === "KeyH") {
        setPlayerState(PlayerState.HIT_REACT);
        isInCombatRef.current = true;
        lastAnimationTimeRef.current = now;
      } else if (e.code === "KeyT") {
        setPlayerState(PlayerState.DEATH);
        isInCombatRef.current = true;
        lastAnimationTimeRef.current = now;
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  // Frame update to detect movement and update player state
  useFrame(() => {
    // Don't update movement states during combat animations
    if (isInCombatRef.current) return;

    const position = group.current?.position;
    if (!position) return;

    // Get movement controls
    const { forward, backward, leftward, rightward, run, jump } = get();

    // Calculate distance moved since last frame
    const dx = position.x - prevPositionRef.current[0];
    const dy = position.y - prevPositionRef.current[1];
    const dz = position.z - prevPositionRef.current[2];
    const distanceMoved = Math.sqrt(dx * dx + dy * dy + dz * dz);

    // Update prev position for next frame
    prevPositionRef.current = [position.x, position.y, position.z];

    // Check if in air (jumping)
    if (jump && isOnGround.current) {
      setPlayerState(PlayerState.JUMP);
      isOnGround.current = false; // Set to false when jumping
    }
    // Determine state based on movement
    else if (
      distanceMoved > MOVEMENT_THRESHOLD ||
      forward ||
      backward ||
      leftward ||
      rightward
    ) {
      if (run) {
        setPlayerState(PlayerState.RUN);
      } else {
        setPlayerState(PlayerState.WALK);
      }
    } else {
      setPlayerState(PlayerState.IDLE);
    }

    // Check if player is on the ground
    if (position.y <= 0.1) {
      isOnGround.current = true;
    }
  });

  // Debug controls in Leva panel
  useControls("Player Controls", {
    currentState: {
      value: playerState,
      disabled: true,
    },
    Actions: folder({
      Attack: button(() => {
        if (!isInCombatRef.current) {
          setPlayerState(PlayerState.ATTACK);
          isInCombatRef.current = true;
        }
      }),
      SpellCast: button(() => {
        if (!isInCombatRef.current) {
          setPlayerState(PlayerState.SPELL_CAST);
          isInCombatRef.current = true;
        }
      }),
      HitReact: button(() => {
        if (!isInCombatRef.current) {
          setPlayerState(PlayerState.HIT_REACT);
          isInCombatRef.current = true;
        }
      }),
      Death: button(() => {
        setPlayerState(PlayerState.DEATH);
        isInCombatRef.current = true;
      }),
      forceIdle: button(() => {
        setPlayerState(PlayerState.IDLE);
        isInCombatRef.current = false;
      }),
    }),
    AnimationInfo: folder({
      availableAnimations: {
        value: Object.keys(PLAYER_ANIMS).map(
          (key) => `${key}: ${getSimpleName(PLAYER_ANIMS[key])}`
        ),
        disabled: true,
      },
    }),
  });

  return (
    <group
      ref={group}
      position={finalPosition}
      scale={scale}
      {...props}
      dispose={null}
    >
      <group name="Root_Scene">
        <group name="RootNode">
          <group
            name="CharacterArmature"
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          >
            <primitive object={nodes.Root} />
          </group>
          <skinnedMesh
            name="Skeleton"
            geometry={nodes.Skeleton.geometry}
            material={materials.AtlasMaterial}
            skeleton={nodes.Skeleton.skeleton}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
        </group>
      </group>
    </group>
  );
}

// Preload the 3D model for performance
useGLTF.preload("./Skeleton.glb");

export default Player;
