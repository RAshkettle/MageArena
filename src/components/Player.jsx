/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/Skeleton.glb -o src/components/Player.jsx -r public 
*/

import React, { useEffect, useState } from "react";
import { useGraph, useFrame } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import { useControls, folder, button } from "leva";
import * as THREE from "three";
import PLAYER_ANIMS from "./player_animations";
import { useKeyboardControls } from "@react-three/drei";

// Player state machine states
const PlayerState = {
  IDLE: "idle",
  WALK: "walk",
  RUN: "run",
};

/**
 * @typedef {Object} PlayerProps
 * @property {number} [position] - Array or Vector3 for player position [x, y, z]
 * @property {number} [positionX=0] - X position of the player
 * @property {number} [positionY=0] - Y position of the player
 * @property {number} [positionZ=0] - Z position of the player
 * @property {number} [scale=1] - Scale of the player model
 * @property {boolean} [visible=true] - Whether the player is visible
 */

/**
 * Player component that renders a 3D skeleton model with animations
 *
 * @param {PlayerProps} props - The component props
 * @returns {JSX.Element} The player mesh component
 */
export function Player({
  position = [0, 0, 0],
  positionX,
  positionY,
  positionZ,
  scale = 1,
  ...props
}) {
  // State machine for player animations
  const [playerState, setPlayerState] = useState(PlayerState.IDLE);
  const [prevPosition, setPrevPosition] = useState([0, 0, 0]);

  // Movement detection threshold
  const MOVEMENT_THRESHOLD = 0.001;

  // Get movement controls state
  const [, get] = useKeyboardControls();

  // Allow individual position coordinates to override the position array
  const finalPosition = [
    positionX !== undefined ? positionX : position[0],
    positionY !== undefined ? positionY : position[1],
    positionZ !== undefined ? positionZ : position[2],
  ];

  /** @type {React.RefObject<import('three').Group>} */
  const group = React.useRef();

  // Load the model
  const { scene, animations } = useGLTF("./Skeleton.glb");

  // Create a clone of the scene with proper skeleton handling
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);

  // Extract nodes and materials from the cloned scene
  const { nodes, materials } = useGraph(clone);

  // Set up animations
  const { actions, names } = useAnimations(animations, group);

  // Crossfade to a new animation
  const fadeToAction = (newAction, duration = 0.2) => {
    if (!actions[newAction]) return;

    // Get current active animations
    const currentRunning = Object.values(actions).find(
      (action) => action.isRunning() && action._clip.name !== newAction
    );

    // If we have a currently running animation that's different from the new one
    if (currentRunning) {
      // Set up crossfade
      actions[newAction].reset();
      actions[newAction].setLoop(THREE.LoopRepeat);
      actions[newAction].play();
      actions[newAction].crossFadeFrom(currentRunning, duration, true);
    } else {
      // Just play the new animation
      actions[newAction].reset();
      actions[newAction].setLoop(THREE.LoopRepeat);
      actions[newAction].play();
    }
  };

  // Update animation based on player state
  useEffect(() => {
    switch (playerState) {
      case PlayerState.IDLE:
        fadeToAction(PLAYER_ANIMS.IDLE);
        break;
      case PlayerState.WALK:
        fadeToAction(PLAYER_ANIMS.WALK);
        break;
      case PlayerState.RUN:
        fadeToAction(PLAYER_ANIMS.RUN);
        break;
      default:
        fadeToAction(PLAYER_ANIMS.IDLE);
    }
  }, [playerState, actions]);

  // Frame update to detect movement and update player state
  useFrame(() => {
    // Get current position from the group ref
    const currentPosition = group.current?.position;
    if (!currentPosition) return;

    // Get movement controls
    const { forward, backward, leftward, rightward, run } = get();

    // Calculate distance moved since last frame
    const dx = currentPosition.x - prevPosition[0];
    const dy = currentPosition.y - prevPosition[1];
    const dz = currentPosition.z - prevPosition[2];
    const distanceMoved = Math.sqrt(dx * dx + dy * dy + dz * dz);

    // Update prev position for next frame
    setPrevPosition([currentPosition.x, currentPosition.y, currentPosition.z]);

    // Determine new state based on movement and controls
    if (
      distanceMoved > MOVEMENT_THRESHOLD ||
      forward ||
      backward ||
      leftward ||
      rightward
    ) {
      // Moving - either walking or running
      if (run) {
        setPlayerState(PlayerState.RUN);
      } else {
        setPlayerState(PlayerState.WALK);
      }
    } else {
      // Not moving - idle
      setPlayerState(PlayerState.IDLE);
    }
  });

  // Debug controls in Leva panel
  useControls("Player State", {
    currentState: {
      value: playerState,
      disabled: true,
    },
    Animation: folder({
      copyToClipboard: button(() => {
        // Get current animation name based on state
        let currentAnim;
        switch (playerState) {
          case PlayerState.IDLE:
            currentAnim = PLAYER_ANIMS.IDLE;
            break;
          case PlayerState.WALK:
            currentAnim = PLAYER_ANIMS.WALK;
            break;
          case PlayerState.RUN:
            currentAnim = PLAYER_ANIMS.RUN;
            break;
          default:
            currentAnim = PLAYER_ANIMS.IDLE;
        }

        navigator.clipboard
          .writeText(currentAnim)
          .then(() =>
            console.log(`Animation name "${currentAnim}" copied to clipboard!`)
          )
          .catch((err) =>
            console.error("Could not copy animation name: ", err)
          );
      }),
    }),
  });

  return (
    <group
      ref={group}
      position={finalPosition}
      scale={scale}
      {...props}
      dispose={null}
    >
      <group name="Root_Scene">
        <group name="RootNode">
          <group
            name="CharacterArmature"
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          >
            <primitive object={nodes.Root} />
          </group>
          <skinnedMesh
            name="Skeleton"
            geometry={nodes.Skeleton.geometry}
            material={materials.AtlasMaterial}
            skeleton={nodes.Skeleton.skeleton}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
        </group>
      </group>
    </group>
  );
}

// Preload the 3D model for performance
useGLTF.preload("./Skeleton.glb");

export default Player;
